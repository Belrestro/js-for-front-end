// spread operator - це простіше кажучи - і так далі
// він прицює для об'єктів для масивів і для функцій (всюди по різному)

// масив
// для масиву цей оператор вивертає значення масиву назовні
// це корисно у багатьох випадках
const array1 = [1,2,3];
const array2 = [3,4,5];

console.log("об'єднані масиви", array1.concat(array2)); // з'єднуємо 2 масиви
console.log("об'єднані масиви (по новому)", [...array1, ...array2]); // з'єднуємо 2 масиви (по-новому)
console.log('зклонований масив', array2.concat()); // клонуємо масив
console.log('зклонований масив (по новому) більше очевидно', [...array2]); // клонуємо масив
console.log('абсолютно новий масив!', array2 === [...array2]); // але як результат вже новий масив
console.log(...array1); // кожен елемент масиву предається як окремий аргумент

// об'єкт
// для об'єктів те ж саме, тільки розвертати об'єкти можна тільки в нові об'єкти
const obj1 = { a: 1, b: 2};
const obj2 = { c: 1, d: 2};
class SomeClass {
  a = 1;
  method() {
    return 'method works';
  }
}
const insta = new SomeClass();

console.log('всі властивості обох у одному', Object.assign({}, obj1, obj2)); // з'єднуємо об'єкти
console.log('всі властивості обох у одному (по новому)', { ...obj1, ...obj2 }); // з'єднуємо об'єкти (по-новому)
console.log('абсолютно новий об\'єкт', { ...obj1 }); // колонуємо об'єкт, ми цього досягли без обміну прототипів
console.log('об\'єкт новий але влстивості ті ж', obj1 === { ...obj1 }); // але як результат вже новий об'єкт
// console.log(...obj1); // нажаль так не працює для об'єктів
console.log('клонуємо класс (бо екземпляр - це об\'єкт же)', {...insta }); // але всі методи втрачаються
console.log('якщо розвертати об\'єкти і у них однакові властивості то в останнього перевага', {...obj1, ...{ a: 3 }});

// функція
// для функції працює аж твома різними способами
// 1 - при передачі аргументів у функцію (якщо це масив то кожен елемент масиву буде окремим аргументом)
// 2 - при прийому аргументів у фунцію (всі аргументи починаючи зі spread аргументу будуть у масиві spread)

const logAllArguments = (...args) => { // прийом аргументів, у змінній args масив всіх аргументів
  for (const arg of args) {
    console.log('argument', arg);
  }
}
console.log('logAllArguments');
logAllArguments(...[6,1,2,4,5,1,]); // передача арументів, кожен елемент масиву буде окремим аргументом


const bindFunction = (fn, ...rest) => { // перший аргумент - окрема змінна, решта - записуємо весь список аргументів в змінну "rest"
  return (...args) => fn(...rest, ...args);
}

const bindedLog = bindFunction(console.log, '[LOG]', '*[INFO]*');

bindedLog('message recieved');
bindedLog('packege sent');
bindedLog('process completed');