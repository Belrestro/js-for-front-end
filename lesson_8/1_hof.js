// Higher Order Function це просто функція яка передана і викликана в іншій функції

// forEach
// давайте створимо функцію яка буде перебирати масиви
// і приймати функцію що буде викликана для кожного окремо взятого елементу


let forEach = (array, fn) => {
  for (let i=0;i<array.length;i++) { // перебираємо масив
    fn(array[i]); // викликаємо з кожним елементом масиву
  }
};

forEach([1,2,3], (el) => console.log(el));

// треба зробити деякі модифікації, щоб уникнути путанини
// 1 - якщо у нас вже є індекс, чому б не дати його
// функція викликається окремо вона не може зрозуміти який елемент
// переданий в неї, перший, останній, середній
// 2 - якщо вже в нас є масив, можна і його передати, на його підставі
// можна і зробити висновки про останній чи перший елемент

forEach = (array, fn) => {
  for (let i=0;i<array.length;i++) { // все те ж саме
    fn(array[i], i, array); // модифікації
  }
}; // готово

forEach(['a','b','c'], (current, index, array) => console.log(current, index, array));

// классно !!!!

// давайте напишемо функцію аналогічну першій, але вона буде змінювати масив

const map = (array, fn) => {
  const newArray = [];
  forEach(array, (el, i, array) => newArray.push(fn(el, i, array)));
  return newArray;
}

console.log(map([1,2,3], (el) => el + 12));
console.log(map(['a','b','c'], (el) => el + 12));

// суть цих функцій узагальнити роботу пов'язану з перебором
// і використати лише ту частину яка про роботу з окремо взятим елементом

// давайте візмемо функцію яка буде робити якусь важку роботу 
// а після цього викличе вашу функцію і передасть туди результат

const bruteForcePrimes = (n, callback) => {
  setTimeout(() => {
    callback('done');
  }, (n ** 2) * 100); // імітація важкої приці (асинхронна)
}

bruteForcePrimes(5, () => console.log('Heavy calculation done !'));