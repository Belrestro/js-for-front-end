// в javascript є спеціальна одиниця вимірювання щодо ООП
// яка дозволить написати вам об'єктно орієнтований код
// це Class

class Animal {} // "class" - це ключове слово що буде означати декларацію класу
// "Animal" - це назва классу (назви прийнято писати з Великої букви)

// класс по своїй природі - це функція
console.log('type of Animal', typeof Animal);
// функція для створення однакових абстрактних об'єктів
// сенс класу в тому щоб напічкати "прототип" з якого будуть сворюватись
// об'єкти методами і властивостями
// і створювати "схожі" об'єкти

// створювати так:

new Animal(); // "new" це ключове слово (створи мені таки й же об'єкт)
// і оскільки клас це функція то вона викликається дужками

const octopus = new Animal();
const rabbit = new Animal();

// фігурні дужки це тіло класу
// в тілі є два типи речей - 
// 1 - методи пов'язані беспосередньо з самим класом (функцією для створення нових об'єктів)
// 2 - властивості і методи пов'язані лише з "прототипом"

class Car {
	isRunning = false; // стандартна властивість прототипу

	constructor(type) { // функція яка запуститься під час створення нового об'єкта (приймає аргументи)
		this.type = type; // при створенні назначить type прототипу
	}

	start() { // стандартний метод прототипу
		this.isRunning = true; // змінює властивість isRunning у новому об'єкті
	}

	stop() { // стандартний метод прототипу
		this.isRunning = false;
	}
}

// давайте анатомічно розділимо поняття

// класс "class Animal" - функція для створення нових об'єктів
// прототип "prototype" - об'єкт властивості і методи якого використовуються (копіюються) у новому об'єкті
// екземпляр "instance" - створений об'єкт (з допомогою класу) (з прототипом)

// в нашому екземплярі є  методи start() stop()

const audi = new Car('audi');
const opel = new Car('opel');
audi.start();
console.log('audi isRunning', audi.isRunning);
console.log('opel isRunning', opel.isRunning);

// вони змінюють "внутрішній" стан об'єкту
// вони це роблять з допотогою ключового слова this
// this означає - екземпляр
// саме тому лише одна машина заведена, а інша ні

// this можна використовувати у методах прототипу щоб змінювати внутрішній стан екземпляру